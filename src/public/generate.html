<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X402 Nano Banana</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; background-color: #f4f4f9; color: #333; }
        .container { max-width: 800px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: #555; }
        input[type="text"], textarea { width: calc(100% - 22px); padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; transition: border-color 0.3s; }
        input[type="text"]:focus, textarea:focus { border-color: #007bff; outline: none; }
        button { background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: 600; transition: background-color 0.3s ease; width: 100%; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        #message { margin-top: 20px; padding: 15px; border-radius: 6px; display: none; word-break: break-word; }
        #message.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        #message.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #message.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        #imageContainer { margin-top: 30px; text-align: center; }
        #imageContainer img { max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 6px; display: none; }
        .payment-info { background-color: #e9f7ef; border-left: 5px solid #28a745; padding: 15px; margin-bottom: 25px; border-radius: 4px; }
        .payment-info p { margin: 5px 0; }
        .payment-info code { background-color: #fff; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
        .loading-spinner { display: none; border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #007bff; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 20px auto 0; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .debug-info { margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #666; }
        .debug-info summary { cursor: pointer; font-weight: 600; }
        .debug-info pre { margin-top: 8px; background: white; padding: 8px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
<div class="container">
    <h1>X402 Nano Banana</h1>

    <div class="payment-info">
        <h2>Payment Required</h2>
        <p>To generate an image, please send <strong><span id="price">...</span> <span id="asset">...</span></strong> to the following address on the <strong><span id="network">...</span></strong> network:</p>
        <p><strong><code id="walletAddress">...</code></strong></p>
        <p>Timeout: <span id="timeout">...</span> seconds</p>
        <p>After sending, enter the transaction hash below.</p>
    </div>

    <form id="generateForm">
        <div class="form-group">
            <label for="txHash">Payment Transaction Hash:</label>
            <input type="text" id="txHash" name="txHash" placeholder="e.g., 0x..." required>
        </div>
        <div class="form-group">
            <label for="prompt">Image Prompt:</label>
            <textarea id="prompt" name="prompt" rows="3" placeholder="e.g., a photo of a cat astronaut in space" required></textarea>
        </div>
        <button type="submit">Generate Image</button>
    </form>

    <div class="loading-spinner" id="loadingSpinner"></div>
    <div id="message"></div>
    <div id="imageContainer">
        <img id="generatedImage" alt="Generated Image">
    </div>
</div>

<script>
    // X402 Protocol Configuration
    const response = {
        x402Version: 1,
        accepts: [{
            scheme: "exact",
            network: "base",
            maxAmountRequired: "0.1",
            resource: "https://x402-image.onrender.com/generate",
            // resource: "/generate",
            description: "AI Image Generation Service - Pay with crypto to generate images",
            mimeType: "image/png",
            payTo: "0x9a629c2dd7f5c43c11665f69877d08638d1288e6",
            maxTimeoutSeconds: 3600,
            asset: "USDC",

            outputSchema: {
                input: {
                    type: "http",
                    method: "POST",
                    bodyType: "json",
                    bodyFields: {
                        tx: {
                            type: "string",
                            description: "Payment transaction hash",
                            required: true,
                            pattern: "^0x[a-fA-F0-9]{64}$"
                        },
                        prompt: {
                            type: "string",
                            description: "Image generation prompt",
                            required: true,
                            minLength: 1,
                            maxLength: 1000
                        }
                    }
                },
                output: {
                    type: "binary",
                    contentType: "image/png",
                    description: "Generated image in PNG format"
                }
            },

            extra: {
                apiVersion: "1.0",
                provider: "X402 Nano Banana",
                supportedModels: ["gemini-2.5-flash-image"],
                imageSize: "1024x1024"
            }
        }]
    };

    const protocolConfig = response.accepts[0];

    const form = document.getElementById('generateForm');
    const txHashInput = document.getElementById('txHash');
    const promptInput = document.getElementById('prompt');
    const messageDiv = document.getElementById('message');
    const submitButton = document.querySelector('button[type="submit"]');
    const generatedImage = document.getElementById('generatedImage');
    const loadingSpinner = document.getElementById('loadingSpinner');

    // Fetch payment info from the server or use default config
    async function fetchPaymentInfo() {
        try {
            const response = await fetch('/payment-info');
            if (response.ok) {
                const data = await response.json();
                updatePaymentUI(data);
            } else {
                updatePaymentUI({
                    priceInUSDC: protocolConfig.maxAmountRequired,
                    networkId: protocolConfig.network,
                    walletAddress: protocolConfig.payTo,
                    asset: protocolConfig.asset,
                    timeout: protocolConfig.maxTimeoutSeconds
                });
            }
        } catch (error) {
            console.error('Error fetching payment info:', error);
            updatePaymentUI({
                priceInUSDC: protocolConfig.maxAmountRequired,
                networkId: protocolConfig.network,
                walletAddress: protocolConfig.payTo,
                asset: protocolConfig.asset,
                timeout: protocolConfig.maxTimeoutSeconds
            });
        }
    }

    function updatePaymentUI(data) {
        document.getElementById('price').textContent = data.priceInUSDC;
        document.getElementById('network').textContent = data.networkId;
        document.getElementById('walletAddress').textContent = data.walletAddress;
        document.getElementById('asset').textContent = data.asset || 'USDC';
        document.getElementById('timeout').textContent = data.timeout || 3600;
    }

    // Parse and display error response with full details
    function displayError(status, responseData, rawResponse) {
        messageDiv.className = 'error';

        let errorMessage = '<strong>Error:</strong> ';

        // Handle different error response formats
        if (responseData) {
            if (responseData.error) {
                errorMessage += `${responseData.error}`;
                if (responseData.message) {
                    errorMessage += ` - ${responseData.message}`;
                }
                if (responseData.providedTxHash) {
                    errorMessage += `<br><small>Transaction: ${responseData.providedTxHash}</small>`;
                }
            } else if (responseData.message) {
                errorMessage += responseData.message;
            } else if (typeof responseData === 'string') {
                errorMessage += responseData;
            } else {
                errorMessage += `HTTP ${status} - See details below`;
            }
        } else {
            errorMessage += `HTTP ${status} - Request failed`;
        }

        // Add debug info for troubleshooting
        const debugInfo = document.createElement('details');
        debugInfo.className = 'debug-info';
        debugInfo.innerHTML = `
            <summary>Debug Information</summary>
            <pre>${JSON.stringify({
            status: status,
            response: responseData,
            raw: rawResponse ? rawResponse.substring(0, 500) : 'N/A'
        }, null, 2)}</pre>
        `;

        messageDiv.innerHTML = errorMessage;
        messageDiv.appendChild(debugInfo);
        messageDiv.style.display = 'block';
    }

    // On page load
    document.addEventListener('DOMContentLoaded', () => {
        fetchPaymentInfo();

        const urlParams = new URLSearchParams(window.location.search);
        const txFromUrl = urlParams.get('tx');
        const promptFromUrl = urlParams.get('prompt');
        if (txFromUrl) txHashInput.value = txFromUrl;
        if (promptFromUrl) promptInput.value = promptFromUrl;
    });

    // Real-time transaction hash validation
    txHashInput.addEventListener('input', () => {
        const txHash = txHashInput.value.trim();
        const schema = protocolConfig.outputSchema.input.bodyFields.tx;
        const txHashRegex = new RegExp(schema.pattern);

        if (messageDiv.textContent.includes('Invalid Transaction Hash format')) {
            messageDiv.style.display = 'none';
            messageDiv.textContent = '';
        }

        if (txHash && !txHashRegex.test(txHash)) {
            txHashInput.style.borderColor = '#dc3545';
            submitButton.disabled = true;
        } else {
            txHashInput.style.borderColor = '#ddd';
            submitButton.disabled = false;
        }
    });

    form.addEventListener('submit', async (event) => {
        event.preventDefault();

        // Reset UI
        messageDiv.style.display = 'none';
        messageDiv.innerHTML = '';
        generatedImage.style.display = 'none';
        generatedImage.src = '';
        loadingSpinner.style.display = 'block';
        submitButton.disabled = true;

        const txHash = txHashInput.value.trim();
        const prompt = promptInput.value.trim();

        try {
            const apiResponse = await fetch(protocolConfig.resource, {
                method: protocolConfig.outputSchema.input.method,
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': protocolConfig.mimeType,
                },
                body: JSON.stringify({
                    tx: txHash,
                    prompt: prompt
                })
            });

            loadingSpinner.style.display = 'none';
            submitButton.disabled = false;

            // Get content type to determine response format
            const contentType = apiResponse.headers.get('content-type') || '';

            if (!apiResponse.ok) {
                // Try to parse error response
                let errorData = null;
                let rawText = null;

                try {
                    if (contentType.includes('application/json')) {
                        errorData = await apiResponse.json();
                    } else {
                        rawText = await apiResponse.text();
                        // Try to parse as JSON anyway
                        try {
                            errorData = JSON.parse(rawText);
                        } catch (e) {
                            errorData = { message: rawText };
                        }
                    }
                } catch (parseError) {
                    console.error('Failed to parse error response:', parseError);
                    errorData = { message: 'Failed to parse server response' };
                }

                displayError(apiResponse.status, errorData, rawText);
            } else {
                // Success - display image
                const imageBlob = await apiResponse.blob();
                const imageUrl = URL.createObjectURL(imageBlob);
                generatedImage.src = imageUrl;
                generatedImage.style.display = 'block';

                messageDiv.className = 'success';
                messageDiv.innerHTML = '<strong>Success!</strong> Image generated successfully.';
                messageDiv.style.display = 'block';
            }
        } catch (error) {
            console.error('Error during image generation:', error);
            loadingSpinner.style.display = 'none';
            submitButton.disabled = false;

            messageDiv.className = 'error';
            messageDiv.innerHTML = `<strong>Network Error:</strong> ${error.message}<br><small>Please check your connection and try again.</small>`;
            messageDiv.style.display = 'block';
        }
    });

    // Expose config for external access
    window.acceptsConfig = response;
</script>
</body>
</html>